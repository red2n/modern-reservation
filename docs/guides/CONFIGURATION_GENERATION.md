# Configuration Generation Guide

## üéØ Problem Solved

Previously, port configurations were scattered across multiple files:
- Java services: `application.yml`
- Node.js services: `.env` files
- Docker: `docker-compose.yml`
- Kubernetes: ConfigMaps

**Result:** Port conflicts, inconsistencies, maintenance nightmare.

**Solution:** Single source of truth with automatic config generation.

## üèóÔ∏è Architecture

```
Port Manager Registry (Single Source of Truth)
         ‚Üì
Configuration Generator
         ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚Üì                 ‚Üì
Java Configs    Node.js Configs    TypeScript    Kubernetes
application.yml     .env           constants      ConfigMap
```

## üöÄ Quick Start

### Generate All Configurations

```bash
# Generate all config files from port registry
./dev.sh config-generate
```

This generates:
- ‚úÖ `.env.ports` - Master environment file
- ‚úÖ `application-ports.yml` for each Java service
- ‚úÖ `.env.ports` for each Node.js service
- ‚úÖ TypeScript constants in `libs/shared/schemas/src/ports.ts`
- ‚úÖ Java constants class `ServicePorts.java`
- ‚úÖ Kubernetes ConfigMap

### Selective Generation

```bash
# Only Spring Boot configs
./dev.sh config-spring

# Only Node.js configs
./dev.sh config-node

# Only TypeScript constants
./dev.sh config-typescript
```

## üìù Using Generated Configurations

### 1. Java Services (Spring Boot)

#### Step 1: Import the generated config

Edit your `application.yml`:

```yaml
spring:
  config:
    import:
      - "optional:file:./application-ports.yml"  # Add this line
```

#### Step 2: Use the imported ports

**Before (hardcoded):**
```yaml
server:
  port: 8081  # ‚ùå Hardcoded, might conflict
```

**After (from registry):**
```yaml
server:
  port: ${server.port}  # ‚úÖ From application-ports.yml
  address: ${server.address}
```

#### Full Example - reservation-engine

**File:** `apps/backend/java-services/business-services/reservation-engine/src/main/resources/application.yml`

```yaml
spring:
  application:
    name: reservation-engine
  config:
    import:
      - "optional:file:./application-ports.yml"  # Import generated config
      - "configserver:${CONFIG_SERVER_URL}"

server:
  port: ${server.port}        # Uses 8100 from application-ports.yml
  address: ${server.address}  # Uses 127.0.0.1 (internal only)
  servlet:
    context-path: ${server.servlet.context-path}

# Eureka client uses generated values
eureka:
  client:
    serviceUrl:
      defaultZone: ${eureka.client.serviceUrl.defaultZone}

# Kafka uses generated values
spring:
  kafka:
    bootstrap-servers: ${spring.kafka.bootstrap-servers}
```

### 2. Node.js Services

#### Step 1: Load the generated .env file

**File:** `apps/backend/node-services/auth-service/src/index.ts`

```typescript
import { config } from 'dotenv';
import path from 'path';

// Load generated port configuration
config({ path: path.join(__dirname, '../.env.ports') });
config({ path: path.join(__dirname, '../.env') }); // Your custom config

const PORT = process.env.PORT || 3100;
const HOST = process.env.HOST || '127.0.0.1';

const server = Fastify({
  logger: true,
});

// Use environment variables from .env.ports
server.listen({
  port: Number(PORT),
  host: HOST,
}, (err, address) => {
  if (err) throw err;
  console.log(`Server listening on ${address}`);
});
```

#### Step 2: Use service URLs

```typescript
// Eureka registration
const eurekaClient = new Eureka({
  instance: {
    app: process.env.SERVICE_NAME,
    hostName: process.env.EUREKA_HOST,
    port: {
      $: Number(process.env.PORT),
      '@enabled': true,
    },
  },
  eureka: {
    host: process.env.EUREKA_HOST,
    port: Number(process.env.EUREKA_PORT),
  },
});

// Database connection
const dbConfig = {
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  database: process.env.DB_NAME,
};
```

### 3. TypeScript/Frontend

Use the generated constants:

**File:** `libs/shared/schemas/src/ports.ts`

```typescript
// Generated by config generator
export const ServicePorts = {
  GUEST_PORTAL: 3000,
  GATEWAY_SERVICE: 8080,
  AUTH_SERVICE: 3100,
  // ... all services
} as const;

export const ServiceUrls = {
  GUEST_PORTAL: 'http://localhost:3000',
  GATEWAY_SERVICE: 'http://localhost:8080',
  AUTH_SERVICE: 'http://localhost:3100',
  // ... all services
} as const;
```

**Usage in your code:**

```typescript
import { ServicePorts, ServiceUrls } from '@modern-reservation/schemas/ports';

// Instead of hardcoding
const apiUrl = 'http://localhost:8080'; // ‚ùå Hardcoded

// Use constants
const apiUrl = ServiceUrls.GATEWAY_SERVICE; // ‚úÖ From registry
const authPort = ServicePorts.AUTH_SERVICE;  // ‚úÖ Always correct
```

### 4. Java Constants

Use the generated Java class:

**File:** `ServicePorts.java` (auto-generated)

```java
package com.modernreservation.config;

public final class ServicePorts {
    private ServicePorts() {}

    /** Spring Cloud Gateway - Main API Entry Point */
    public static final int GATEWAY_SERVICE = 8080;

    /** Reservation Engine Service */
    public static final int RESERVATION_ENGINE = 8100;

    // ... all services
}
```

**Usage:**

```java
import com.modernreservation.config.ServicePorts;

@Configuration
public class MyConfig {
    @Value("${server.port:#{T(com.modernreservation.config.ServicePorts).RESERVATION_ENGINE}}")
    private int port;

    public String getServiceUrl() {
        return "http://localhost:" + ServicePorts.GATEWAY_SERVICE;
    }
}
```

## üîÑ Workflow

### Initial Setup

```bash
# 1. Update port registry if adding new service
vim libs/shared/port-manager/src/port-registry.ts

# 2. Rebuild port manager
cd libs/shared/port-manager && npm run build

# 3. Generate all configs
./dev.sh config-generate

# 4. Update service imports (one-time per service)
# - Java: Add spring.config.import in application.yml
# - Node: Load .env.ports in index.ts

# 5. Rebuild services
./dev.sh build

# 6. Restart
./dev.sh clean
```

### Adding a New Service

```bash
# 1. Register in port-registry.ts
vim libs/shared/port-manager/src/port-registry.ts

# Add your service:
{
  name: 'my-new-service',
  port: 8160,
  protocol: 'http',
  description: 'My New Service',
  category: ServiceCategory.JAVA_BUSINESS,
  internal: true,  // Not exposed externally
}

# 2. Rebuild and regenerate
cd libs/shared/port-manager && npm run build
./dev.sh config-generate

# 3. Your service automatically gets configuration file!
# - Java: application-ports.yml created
# - Node: .env.ports created
# - TypeScript constant added
```

### Changing a Port

```bash
# 1. Update port-registry.ts
vim libs/shared/port-manager/src/port-registry.ts

# 2. Validate no conflicts
./dev.sh port-validate

# 3. Regenerate all configs
./dev.sh config-generate

# 4. Restart services
./dev.sh clean
```

## üìä Verification

### Check Port Conflicts

```bash
./dev.sh port-check
```

### View Current Configuration

```bash
# List all services
./dev.sh port-list

# Security report
./dev.sh port-security

# Detailed report
./dev.sh port-report
```

## üîê Security Integration

All generated configs respect the security model:

- **Internal services** (`internal: true`): Bind to `127.0.0.1`
- **External services** (`internal: false`): Bind to `0.0.0.0`

```yaml
# Auto-generated based on security setting
server:
  address: 127.0.0.1  # Internal only - not accessible externally
```

## üê≥ Docker Integration

### Use in docker-compose.yml

```yaml
services:
  reservation-engine:
    environment:
      - SERVER_PORT=${RESERVATION_ENGINE_PORT}
      - EUREKA_PORT=${EUREKA_SERVER_PORT}
      - DB_PORT=${POSTGRES_PORT}
    ports:
      - "${RESERVATION_ENGINE_PORT}:${RESERVATION_ENGINE_PORT}"
    env_file:
      - .env.ports
```

## ‚ò∏Ô∏è Kubernetes Integration

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: reservation-engine
spec:
  containers:
  - name: reservation-engine
    envFrom:
    - configMapRef:
        name: service-ports  # Auto-generated ConfigMap
```

## ‚úÖ Best Practices

### DO ‚úÖ

1. **Always regenerate** after changing port registry
   ```bash
   ./dev.sh config-generate
   ```

2. **Use environment variables** in application code
   ```java
   @Value("${server.port}")
   private int port;
   ```

3. **Validate before committing**
   ```bash
   ./dev.sh port-validate
   ```

4. **Import generated configs** in your service configuration
   ```yaml
   spring.config.import: "optional:file:./application-ports.yml"
   ```

### DON'T ‚ùå

1. **Don't hardcode ports** in application.yml or .env
   ```yaml
   server:
     port: 8081  # ‚ùå DON'T DO THIS
   ```

2. **Don't edit generated files manually**
   ```bash
   # All generated files have this warning:
   # DO NOT EDIT MANUALLY - Run: ./dev.sh config-generate
   ```

3. **Don't skip validation**
   ```bash
   ./dev.sh port-validate  # Always run this!
   ```

## üß™ Testing

### Test Generated Config

```bash
# 1. Generate configs
./dev.sh config-generate

# 2. Validate
./dev.sh port-validate

# 3. Check specific service
cd apps/backend/java-services/business-services/reservation-engine
cat src/main/resources/application-ports.yml

# 4. Build and test
./dev.sh build
./dev.sh start
```

## üîß Troubleshooting

### Port Conflict Detected

```bash
‚ùå Port conflict on 3000: guest-portal, grafana
```

**Solution:**
1. Check `./dev.sh port-check`
2. Update conflicting port in `port-registry.ts`
3. Regenerate: `./dev.sh config-generate`

### Service Not Using Generated Config

**Java Service:**
```yaml
# Check application.yml has import
spring:
  config:
    import:
      - "optional:file:./application-ports.yml"
```

**Node.js Service:**
```typescript
// Check .env.ports is loaded
config({ path: path.join(__dirname, '../.env.ports') });
```

### Config Not Updated

```bash
# Force regeneration
cd libs/shared/port-manager && npm run build
./dev.sh config-generate
./dev.sh clean
```

## üìö Reference

### Generated Files

| File | Purpose | Update Frequency |
|------|---------|------------------|
| `.env.ports` | Master env file | Every port change |
| `application-ports.yml` | Java service config | Every port change |
| `.env.ports` (per service) | Node.js config | Every port change |
| `ports.ts` | TypeScript constants | Every port change |
| `ServicePorts.java` | Java constants | Every port change |
| `configmap-ports.yaml` | K8s ConfigMap | Every port change |

### Commands

| Command | Description |
|---------|-------------|
| `./dev.sh config-generate` | Generate all configs |
| `./dev.sh config-spring` | Only Java configs |
| `./dev.sh config-node` | Only Node configs |
| `./dev.sh port-validate` | Check for conflicts |
| `./dev.sh port-check` | Port status |
| `./dev.sh port-security` | Security report |

## üéØ Summary

**Before:**
- ‚ùå Ports scattered across 20+ files
- ‚ùå Frequent conflicts
- ‚ùå Manual synchronization needed
- ‚ùå No single source of truth

**After:**
- ‚úÖ Single port registry
- ‚úÖ Automatic config generation
- ‚úÖ Conflict detection
- ‚úÖ Type-safe constants
- ‚úÖ Security-aware configuration
- ‚úÖ One command to update everything

**Result:** Consistent, maintainable, conflict-free port management! üéâ
